{
rbf.cv(z ~ 1, ~ x + y, data = data, neighbors = k)
},
error = function(e) NA
)
error_vec[i] <- error
}
cat("Mejor número de vecinos:", kValues[which.min(error_vec)], "con error mínimo:", round(min(error_vec), 4), "\n")
rm(list = ls())
data <-  data.frame (
x = c(370400, 370900, 366100, 367100, 371000),
y = c(415700, 412400, 414700, 411400, 414900),
z = c(52.6, 40.8, 48.3, 46.7, 47.1)
)
kValues <- 1:5
error_vec <- numeric(length(kValues))
for (i in seq_along(kValues)){
k <- kValues[i]
error <- tryCatch(
{
rbf.cv(z ~ 1, ~ x + y, data = data, neighbors = k)
},
error = function(e) NA
)
error_vec[i] <- error
}
cat("Mejor número de vecinos:", kValues[which.min(error_vec)], "con error mínimo:", round(min(error_vec), 4), "\n")
data <-  data.frame (
x = c(370400, 370900, 366100, 367100, 371000),
y = c(415700, 412400, 414700, 411400, 414900),
z = c(52.6, 40.8, 48.3, 46.7, 47.1)
)
# --- Buscar el mejor valor de q  --- #
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 5)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
xy <- data[,1:2]
z <- data$z
s0 <- c(369000,414300)
s0 <- as.data.frame(cbind(x=s0[1],y=s0[2]))
m.dist <- as.matrix(dist(rbind(xy,s0)))
coordinates(s0) <- c("x", "y")
dist.s0 <- m.dist[nrow(m.dist),1:(ncol(m.dist)-1)]           # vector de distancias al punto So.
vec.orden <- order(dist.s0)                                  # vecinos ordenados
dist.vec.cerca <- dist.s0[vec.orden[1:5]]                    # vecinos mas cercanos "5"
factor.p <- pVal[which.min(rmspeVal)]
Peso.i <- dist.vec.cerca^(-factor.p)/sum(dist.vec.cerca^(-factor.p))
Pronostico.So <- z[vec.orden[1:5]]%*%Peso.i
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 2, func = "ST")
rbf
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 3, func = "ST")
rbf
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 4, func = "ST")
4
rbf
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 5, func = "ST")
rbf
plot(data)
plot(data$x,data$y)
point(s0)
x11()
plot(data$x, data$y, pch = 19, col = "blue",
xlab = "x (m)", ylab = "y (m)", asp = 1,
main = "Ubicación de s₀ respecto a los puntos conocidos")
text(data$x, data$y, labels = paste0("s", 1:5), pos = 3, col = "blue")
# Agregar el punto s0
points(s0$x, s0$y, pch = 17, col = "red", cex = 1.5)
text(s0$x, s0$y, labels = "s₀", pos = 3, col = "red")
plot(data$x, data$y, pch = 19, col = "blue",
xlab = "x (m)", ylab = "y (m)", asp = 1,
main = "Ubicación de s0 respecto a los puntos conocidos")
text(data$x, data$y, labels = paste0("s", 1:5), pos = 3, col = "blue")
# Agregar el punto s0
points(s0$x, s0$y, pch = 17, col = "red", cex = 1.5)
text(s0$x, s0$y, labels = "s₀", pos = 3, col = "red")
plot(data$x, data$y, pch = 19, col = "blue",
xlab = "x (m)", ylab = "y (m)", asp = 1,
main = "Ubicación de s0 respecto a los puntos conocidos")
text(data$x, data$y, labels = paste0("s", 1:5), pos = 3, col = "blue")
# Agregar el punto s0
points(s0$x, s0$y, pch = 17, col = "red", cex = 1.5)
text(s0$x, s0$y, labels = "s0", pos = 3, col = "red")
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 3)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 2)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
class(data)
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 2)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
xy <- data[,1:2]
z <- data$z
s0 <- c(369000,414300)
s0 <- as.data.frame(cbind(x=s0[1],y=s0[2]))
m.dist <- as.matrix(dist(rbind(xy,s0)))
coordinates(s0) <- c("x", "y")
dist.s0 <- m.dist[nrow(m.dist),1:(ncol(m.dist)-1)]           # vector de distancias al punto So.
vec.orden <- order(dist.s0)                                  # vecinos ordenados
dist.vec.cerca <- dist.s0[vec.orden[1:5]]                    # vecinos mas cercanos "5"
factor.p <- pVal[which.min(rmspeVal)]
Peso.i <- dist.vec.cerca^(-factor.p)/sum(dist.vec.cerca^(-factor.p))
Pronostico.So <- z[vec.orden[1:5]]%*%Peso.i
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 5, func = "ST")
rbf
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 4, func = "ST")
rbf
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=1,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=2,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=3,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=4,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=5,func="ST")
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 4, func = "ST")
rbf
rm(list = ls())
data <-  data.frame (
x = c(370400, 370900, 366100, 367100, 371000),
y = c(415700, 412400, 414700, 411400, 414900),
z = c(52.6, 40.8, 48.3, 46.7, 47.1)
)
s0 <- c(369000,414300)
s0 <- as.data.frame(cbind(x=s0[1],y=s0[2]))
plot(data$x, data$y, pch = 19, col = "blue",
xlab = "x (m)", ylab = "y (m)", asp = 1,
main = "Ubicación de s0 respecto a los puntos conocidos")
text(data$x, data$y, labels = paste0("s", 1:5), pos = 3, col = "blue")
# Agregar el punto s0
points(s0$x, s0$y, pch = 17, col = "red", cex = 1.5)
text(s0$x, s0$y, labels = "s0", pos = 3, col = "red")
# --- Buscar el mejor valor de q  --- #
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 2)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
xy <- data[,1:2]
z <- data$z
m.dist <- as.matrix(dist(rbind(xy,s0)))
coordinates(s0) <- c("x", "y")
dist.s0 <- m.dist[nrow(m.dist),1:(ncol(m.dist)-1)]           # vector de distancias al punto So.
vec.orden <- order(dist.s0)                                  # vecinos ordenados
dist.vec.cerca <- dist.s0[vec.orden[1:5]]                    # vecinos mas cercanos "5"
factor.p <- pVal[which.min(rmspeVal)]
Peso.i <- dist.vec.cerca^(-factor.p)/sum(dist.vec.cerca^(-factor.p))
Pronostico.So <- z[vec.orden[1:5]]%*%Peso.i
# --- Calculando el RBF --- #
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=1,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=1,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=4,func="ST")
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 4, func = "ST")
rbf
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
rm(list = ls())
path <- "Descargas/base_conta_2.xlsx"
data <- as.csv(path)
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
library(readr)
path <- "Descargas/base_conta_2.xlsx"
dataxlsx <- read_excel(path)
path <- "D:/base_conta_2.xlsx"
dataxlsx <- read_excel(path)
data <- write_csv(dataxlsx,"D:/base_conta_2.csv")
View(data)
rm(list = ls())
path <- "D:/base_final.xlsx"
dataxlsx <- read_excel(path)
data <- write_csv(dataxlsx,"D:/base_final.csv")
View(data)
df <- dplyr::select(Latitud,Longitud,Cromo.Total..Cr)
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
df
head(df)
for (col in names(df)) {
df[[col]] <- as.numeric(df[[col]])
}
head(df)
?st_as_sf
crom <- st_as_sf(data, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(preci, crs = 3116)
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(data, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom
plot(crom)
x11()
plot(crom)
head(crom)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
head(crom)
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
head(crom.df)
?rename
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
crom.sp <- crom.df
coordinates(crom.sp) <- ~x+y
geoCrom <- as.geodata(crom.df, coords.col=2:3, data.col=1)
plot(geoCrom)
summary(lm(z~x+y, data=crom.df))
?spatstat
install.packages("spatstat")
?spatstat
library(MASS)
library(spatstat)
library(spatial)
library(car)
#library(spacemakeR)
#library(maptools)
#library(geoR)
#library(rgdal)
#library(shapefiles)
library(splancs)
library(spdep)
x11()
P1=clickppp(30)
plot.ppp(P1)
str(pq)
str(P1)
set.seed(123)
X <- runifpoint(20)
Y <- runifpoint(10)
S <- superimpose(X, Y)
X11()
plot(S)
set.seed(123)
Po <- rpoispp(100) # random points puntual process
plot(Po)
lambda <- function(x, y) 20 * (x + y)
plot(rpoispp(lambda))
ejem <- density(P1)
plot(ejem)
plot(P1, add = TRUE, cex = 0.5)
persp(ejem)
contour(ejem)
ejem <- density(P1)
plot(ejem)
plot(P1, add = TRUE, cex = 0.5)
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
data <- read_csv("D:/base_final.csv")
data <- read.csv("D:/base_final.csv")
rm(list = ls())
data <- read.csv("D:/base_final.csv")
data
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(dataxlsx,Latitud,Longitud,Cromo.Total..Cr)
path <- "D:base_final.xlsx"
dataxlsx <- read_excel(path)
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(dataxlsx,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
path <- "D:base_final.xlsx"
dataxlsx <- read_excel(path)
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
x11()
crom.sp <- crom.df
coordinates(crom.sp) <- ~x+y
geoCrom <- as.geodata(crom.df, coords.col=2:3, data.col=1)
summary(lm(z~x+y, data=crom.df))
plot(geoCrom)
summary(geoCrom)
hist(geoCrom$data, freq = FALSE, breaks = 12, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = TRUE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 5, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 10, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks =5, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
## Q-Q Plot
qqnorm(geoCrom$data, ylab = "Cromo", xlab = "Cuantiles teóricos",
main="QQ-Plot Cromo")
qqline(geoCrom$data)
boxplot(geoCrom$data, main = "Box-Plot Cromo", notch = FALSE, horizontal = TRUE, xlab = "Cromo")
geoCrom
qqnorm(geoCrom$data, ylab = "Cromo", xlab = "Cuantiles teóricos",
main="QQ-Plot Cromo")
qqline(geoCrom$data)
boxplot(geoCrom$data, main = "Box-Plot Cromo", notch = FALSE, horizontal = TRUE, xlab = "Cromo")
View(data)
# Pruebas de normalidad
shapiro.test(geoCrom$data)
# Obteniendo Distancia Máxima
dist <- as.matrix(dist(geoCrom$coords))
distmax <-  max(dist)/2
# Verificando Tendencia
mod <- lm(z~x+y,data=crom.df)
summary(mod)
rios <- st_read("D:/SistemaHídrico/SistemaHidrico.shp")
plot(st_geometry(rios))
rios.sp<- as(rios, "Spatial")
puntos <- spsample(rios.sp,20000, "regular")
plot(puntos)
rios.sp<- as(rios, "Spatial")
proj4string(rios.sp) <- CRS("+init=epsg:3116")
puntos <- spsample(rios.sp,20000, "regular")
gridded(puntos) <- TRUE
proj4string(puntos) <- CRS("+init=epsg:3116")
plot(puntos)
?graph.idw
graph.idw(z~ 1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=15, nmin=15,pleg = "center", progress=T)
nrow(crom.df)
graph.idw(z~ 1, ~x+y, data=crom.df, np=puntos, p.dmax=5, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~ 1, ~x+y, data=crom.df, np=puntos, p.dmax=500, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~ 1, ~x+y, data=crom.df, np=100, p.dmax=500, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=5, nmax=15, nmin=15,pleg = "center", progress=T)
example(graph.idw)
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=15, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~1, data=crom.sp, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
graph.idw(z~1, ~x+y, data=crom.sp, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
crom.df
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
neigVal = list(25,25)
# Mostrar esto en el informe - calcula el mejor idw
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=neigVal[[1]], nmin=neigVal[[2]],pleg = "center", progress=T)
# --- Crear SpatialPointsDataFrame para df1 con coordenadas ---
proj4string(crom.sp) <- CRS("+init=epsg:3116")
# --- Interpolación IDW con el mejor q ---
idw <- idw(z ~ 1, crom.sp, newdata = puntos, idp = bstIdw$p, nmax = neigVal[[1]], nmin = neigVal[[2]])
gridded(idw) <-  TRUE
# --- Visualización de la interpolación ---
spplot(idw["var1.pred"], cuts = 60, scales = list(draw = TRUE),
xlab = "Este (m)", ylab = "Norte (m)", main = "Interpolación IDW del Cromo",
auto.key = FALSE)
idw
bstIdw$p
str(bstIdw)
bstIdw$P
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=neigVal[[1]], nmin=neigVal[[2]],pleg = "topright", progress=T)
bstIdw$P
bstIdw$p
bstIdw$rmspe
bstIdw$table$P
proj4string(crom.sp) <- CRS("+init=epsg:3116")
idw <- idw(z ~ 1, crom.sp, newdata = puntos, idp = bstIdw$table$P, nmax = neigVal[[1]], nmin = neigVal[[2]])
gridded(idw) <-  TRUE
spplot(idw["var1.pred"], cuts = 60, scales = list(draw = TRUE),
xlab = "Este (m)", ylab = "Norte (m)", main = "Interpolación IDW del Cromo",
auto.key = FALSE)
library(ggplot)
library(ggplot2)
library(spdep)
install.package("Rcpp")
install.packages("Rcpp")
LS
# Taller 1 Econometria
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Tareas")
