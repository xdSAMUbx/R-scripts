s0 <- c(369000,414300)
s0 <- as.data.frame(cbind(x=s0[1],y=s0[2]))
plot(data$x, data$y, pch = 19, col = "blue",
xlab = "x (m)", ylab = "y (m)", asp = 1,
main = "Ubicación de s0 respecto a los puntos conocidos")
text(data$x, data$y, labels = paste0("s", 1:5), pos = 3, col = "blue")
# Agregar el punto s0
points(s0$x, s0$y, pch = 17, col = "red", cex = 1.5)
text(s0$x, s0$y, labels = "s0", pos = 3, col = "red")
# --- Buscar el mejor valor de q  --- #
pVal <- seq(0.25, 7, 0.25)
rmspeVal <- numeric(length(pVal))
nVal <- list(5, 2)
pb <- txtProgressBar(min = 0, max = length(pVal), style = 3)
for (i in seq_along(pVal)) {
p <- pVal[i]
rmspe <- tryCatch(
{
idw.cv(z ~ 1, ~ x + y, data = data, nmax = nVal[[1]], nmin = nVal[[2]], p = p)
},
error = function(e) NA
)
rmspeVal[i] <- rmspe
setTxtProgressBar(pb, i)
}
close(pb)
cat("El mejor valor es", pVal[which.min(rmspeVal)], "con un RMSPE:", min(rmspeVal), "\n")
cat("El peor valor es", pVal[which.max(rmspeVal)], "con un RMSPE:", max(rmspeVal), "\n")
xy <- data[,1:2]
z <- data$z
m.dist <- as.matrix(dist(rbind(xy,s0)))
coordinates(s0) <- c("x", "y")
dist.s0 <- m.dist[nrow(m.dist),1:(ncol(m.dist)-1)]           # vector de distancias al punto So.
vec.orden <- order(dist.s0)                                  # vecinos ordenados
dist.vec.cerca <- dist.s0[vec.orden[1:5]]                    # vecinos mas cercanos "5"
factor.p <- pVal[which.min(rmspeVal)]
Peso.i <- dist.vec.cerca^(-factor.p)/sum(dist.vec.cerca^(-factor.p))
Pronostico.So <- z[vec.orden[1:5]]%*%Peso.i
# --- Calculando el RBF --- #
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=1,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=1,func="ST")
rbf.cv(z~1,data,eta=0.001, rho=0.01,n.neig=4,func="ST")
rbf <- rbf(z ~ 1,data, eta=0.001, rho = 0.01, newdata = s0, n.neigh = 4, func = "ST")
rbf
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
rm(list = ls())
path <- "Descargas/base_conta_2.xlsx"
data <- as.csv(path)
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
library(readr)
path <- "Descargas/base_conta_2.xlsx"
dataxlsx <- read_excel(path)
path <- "D:/base_conta_2.xlsx"
dataxlsx <- read_excel(path)
data <- write_csv(dataxlsx,"D:/base_conta_2.csv")
View(data)
rm(list = ls())
path <- "D:/base_final.xlsx"
dataxlsx <- read_excel(path)
data <- write_csv(dataxlsx,"D:/base_final.csv")
View(data)
df <- dplyr::select(Latitud,Longitud,Cromo.Total..Cr)
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
df
head(df)
for (col in names(df)) {
df[[col]] <- as.numeric(df[[col]])
}
head(df)
?st_as_sf
crom <- st_as_sf(data, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(preci, crs = 3116)
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(data, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom
plot(crom)
x11()
plot(crom)
head(crom)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
head(crom)
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
head(crom.df)
?rename
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
crom.sp <- crom.df
coordinates(crom.sp) <- ~x+y
geoCrom <- as.geodata(crom.df, coords.col=2:3, data.col=1)
plot(geoCrom)
summary(lm(z~x+y, data=crom.df))
?spatstat
install.packages("spatstat")
?spatstat
library(MASS)
library(spatstat)
library(spatial)
library(car)
#library(spacemakeR)
#library(maptools)
#library(geoR)
#library(rgdal)
#library(shapefiles)
library(splancs)
library(spdep)
x11()
P1=clickppp(30)
plot.ppp(P1)
str(pq)
str(P1)
set.seed(123)
X <- runifpoint(20)
Y <- runifpoint(10)
S <- superimpose(X, Y)
X11()
plot(S)
set.seed(123)
Po <- rpoispp(100) # random points puntual process
plot(Po)
lambda <- function(x, y) 20 * (x + y)
plot(rpoispp(lambda))
ejem <- density(P1)
plot(ejem)
plot(P1, add = TRUE, cex = 0.5)
persp(ejem)
contour(ejem)
ejem <- density(P1)
plot(ejem)
plot(P1, add = TRUE, cex = 0.5)
library(RGeostats)
library(geoR)
library(gstat)
library(geospt)
library(geosptdb)
library(sp)
library(sf)
library(intamap) # Revisar, aparentemente fue descontinuada
library(FNN)
library(xtable)
library(readxl)
library(ggplot2)
library(scatterplot3d)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lattice)
library(gridExtra)
library(beepr)
data <- read_csv("D:/base_final.csv")
data <- read.csv("D:/base_final.csv")
rm(list = ls())
data <- read.csv("D:/base_final.csv")
data
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(dataxlsx,Latitud,Longitud,Cromo.Total..Cr)
path <- "D:base_final.xlsx"
dataxlsx <- read_excel(path)
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(dataxlsx,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
path <- "D:base_final.xlsx"
dataxlsx <- read_excel(path)
data <- read.csv("D:/base_final.csv")
df <- dplyr::select(data,Latitud,Longitud,Cromo.Total..Cr)
crom <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
crom <- st_transform(crom, crs = 3116)
crom <- crom %>% rename("z" = "Cromo.Total..Cr")
crom.df <- cbind(st_drop_geometry(crom), st_coordinates(crom))
crom.df <- crom.df %>% rename("x" = "X")
crom.df <- crom.df %>% rename("y" = "Y")
head(crom.df)
x11()
crom.sp <- crom.df
coordinates(crom.sp) <- ~x+y
geoCrom <- as.geodata(crom.df, coords.col=2:3, data.col=1)
summary(lm(z~x+y, data=crom.df))
plot(geoCrom)
summary(geoCrom)
hist(geoCrom$data, freq = FALSE, breaks = 12, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = TRUE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 8, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 5, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks = 10, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
hist(geoCrom$data, freq = FALSE, breaks =5, xlab = "Cromo", ylab = "Frecuencia",
main="Histograma de la Presencia de Cromo")
curve(dnorm(x, mean = mean(geoCrom$data), sd = sd(geoCrom$data)), add = TRUE)
## Q-Q Plot
qqnorm(geoCrom$data, ylab = "Cromo", xlab = "Cuantiles teóricos",
main="QQ-Plot Cromo")
qqline(geoCrom$data)
boxplot(geoCrom$data, main = "Box-Plot Cromo", notch = FALSE, horizontal = TRUE, xlab = "Cromo")
geoCrom
qqnorm(geoCrom$data, ylab = "Cromo", xlab = "Cuantiles teóricos",
main="QQ-Plot Cromo")
qqline(geoCrom$data)
boxplot(geoCrom$data, main = "Box-Plot Cromo", notch = FALSE, horizontal = TRUE, xlab = "Cromo")
View(data)
# Pruebas de normalidad
shapiro.test(geoCrom$data)
# Obteniendo Distancia Máxima
dist <- as.matrix(dist(geoCrom$coords))
distmax <-  max(dist)/2
# Verificando Tendencia
mod <- lm(z~x+y,data=crom.df)
summary(mod)
rios <- st_read("D:/SistemaHídrico/SistemaHidrico.shp")
plot(st_geometry(rios))
rios.sp<- as(rios, "Spatial")
puntos <- spsample(rios.sp,20000, "regular")
plot(puntos)
rios.sp<- as(rios, "Spatial")
proj4string(rios.sp) <- CRS("+init=epsg:3116")
puntos <- spsample(rios.sp,20000, "regular")
gridded(puntos) <- TRUE
proj4string(puntos) <- CRS("+init=epsg:3116")
plot(puntos)
?graph.idw
graph.idw(z~ 1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=15, nmin=15,pleg = "center", progress=T)
nrow(crom.df)
graph.idw(z~ 1, ~x+y, data=crom.df, np=puntos, p.dmax=5, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~ 1, ~x+y, data=crom.df, np=puntos, p.dmax=500, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~ 1, ~x+y, data=crom.df, np=100, p.dmax=500, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=5, nmax=15, nmin=15,pleg = "center", progress=T)
example(graph.idw)
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=15, nmax=15, nmin=15,pleg = "center", progress=T)
graph.idw(z~1, data=crom.sp, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
graph.idw(z~1, ~x+y, data=crom.sp, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
crom.df
graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=25, nmin=25,pleg = "center", progress=T)
neigVal = list(25,25)
# Mostrar esto en el informe - calcula el mejor idw
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=neigVal[[1]], nmin=neigVal[[2]],pleg = "center", progress=T)
# --- Crear SpatialPointsDataFrame para df1 con coordenadas ---
proj4string(crom.sp) <- CRS("+init=epsg:3116")
# --- Interpolación IDW con el mejor q ---
idw <- idw(z ~ 1, crom.sp, newdata = puntos, idp = bstIdw$p, nmax = neigVal[[1]], nmin = neigVal[[2]])
gridded(idw) <-  TRUE
# --- Visualización de la interpolación ---
spplot(idw["var1.pred"], cuts = 60, scales = list(draw = TRUE),
xlab = "Este (m)", ylab = "Norte (m)", main = "Interpolación IDW del Cromo",
auto.key = FALSE)
idw
bstIdw$p
str(bstIdw)
bstIdw$P
bstIdw <- graph.idw(z~1, ~x+y, data=crom.df, np=50, p.dmax=10, nmax=neigVal[[1]], nmin=neigVal[[2]],pleg = "topright", progress=T)
bstIdw$P
bstIdw$p
bstIdw$rmspe
bstIdw$table$P
proj4string(crom.sp) <- CRS("+init=epsg:3116")
idw <- idw(z ~ 1, crom.sp, newdata = puntos, idp = bstIdw$table$P, nmax = neigVal[[1]], nmin = neigVal[[2]])
gridded(idw) <-  TRUE
spplot(idw["var1.pred"], cuts = 60, scales = list(draw = TRUE),
xlab = "Este (m)", ylab = "Norte (m)", main = "Interpolación IDW del Cromo",
auto.key = FALSE)
library(ggplot)
library(ggplot2)
library(spdep)
install.package("Rcpp")
install.packages("Rcpp")
git status
setwd("D:/Universidad/8 Semestre/Econometria/scripts/Tareas")
x <- as.matrix(matrix(c(1:10), 10, 10, TRUE))
x
x <- as.matrix(matrix(c(1:6), 3, 2, TRUE))
x
t(x)
t(x*y)
y <- as.matrix(matrix(c(7:12), 2, 3, TRUE))
t(x*y)
y
x <- as.matrix(matrix(c(1:6), 3, 2, TRUE))
y <- as.matrix(matrix(c(7:12), 2, 3, TRUE))
x*y
t(x%*%y)
t(y)%*%t(x)
# Capítulo 2 #
##############
# Vectores
x <- c(1:5)
# Matrices
x <- as.matrix(matrix(x,5,1,TRUE))
# Transpuesta
tx <- t(x)
# Suma matricial
x <- as.matrix(c(1,2)); y <- as.matrix(c(3,4))
z = x + y
# Producto matricial
z = x%*%t(y)
#
# Matrices Particionadas
A <- as.matrix(matrix(c(1:9),3,3,TRUE))
B <- as.matrix(matrix(c(1:9),3,3,TRUE))
P <-cbind(A,B) # Añade a la derecha
P
P <-rbind(A,B) # Añade debajo
P
P <- cbind(rbind(A,B), rbind(B,A)) # Matriz como las de Geoestadística (Compuesta)
P
# Matrices diagonales
diag(rep(1,3)) # Permite repetir elementos x cantidad de veces
# 3
A = as.matrix(matrix(c(1:6),2,3,T)); B = as.matrix(matrix(c(1:6),3,2,T))
U = as.matrix(matrix(c(1:4),2,2,T)); V = as.matrix(matrix(c(5:8),2,2,T))
W = as.matrix(matrix(c(2,2,3,5),2,2,T)); Z = as.matrix(matrix(c(3,2,3,6),2,2,T))
#3.a
A%*%B
t(A%*%B)
B%*%A
#
#3.a
A%*%B
t(A%*%B)
B%*%A
U
diag(U)
# Error t(a)%*%A
# Error t(a)%*%(A%*%a)
V%*%diag(U)
class(diag(U))
V
V%*%diag(U)
diag(t(B%*%A))
U%*%V%*%W%*%Z
# Matrices diagonales
diag(c(1,1,1)) # Permite repetir elementos x cantidad de veces
rep(1,3
# Matrices diagonales
diag(rep(1,3)) # Permite repetir elementos x cantidad de veces
# Matrices diagonales
diag(rep(1,3)) # Permite repetir elementos x cantidad de veces
U%*%V
diag(diag(U))%*%diag(diag(V))
for (contador in 1:5)
{
cat(contador)
}
x = as.matrix(matrix(c(1:4), 2, 2, T))
x
sum(diag(x))
class(x)
tr(x)
#######################
# Carpeta de trabajo #
######################
setwd("D:/Universidad/8 Semestre/Econometria/scripts/Tareas") # PC
#############################
# Funciones Complementarias #
#############################
source("funciones.R")
tr(x)
x = as.matrix(matrix(c(1:4), 2, 2, T))
tr(x)
#############################
# Funciones Complementarias #
#############################
source("funciones.R")
# Vectores
x <- c(1:5)
# Matrices
x <- as.matrix(matrix(x,5,1,TRUE))
# Transpuesta
tx <- t(x)
# Suma matricial
x <- as.matrix(c(1,2)); y <- as.matrix(c(3,4))
z = x + y
# Producto matricial
z = x%*%t(y)
# Matrices Particionadas
A <- as.matrix(matrix(c(1:9),3,3,TRUE))
B <- as.matrix(matrix(c(1:9),3,3,TRUE))
P <-cbind(A,B) # Añade a la derecha
P <-rbind(A,B) # Añade debajo
P <- cbind(rbind(A,B), rbind(B,A)) # Matriz como las de Geoestadística (Compuesta)
# Matrices diagonales
diag(rep(1,3)) # Permite repetir elementos x cantidad de veces
# 1
a <- as.matrix(c(1:3)); b <- as.matrix(c(4:6)); u <- as.matrix(c(3:1))
v <- as.matrix(c(6:4)); w <- as.matrix(matrix(c(7:9),1,3,TRUE))
a + b
v - a
t(w) + b
3*u
t(w) - a
v/3
a%*%t(b)
b%*%t(a)
# 2
x = as.matrix(c(2,2,-3)); y = as.matrix(c(1,-2,1))
vecP1 <- list(a,b,u,v)
for(i in seq_along(vecP1))
{
if(is.ort(x,vecP1[[i]]))
{
print(i)
break
}
}
for(i in seq_along(vecP1))
{
if(is.ort(y,vecP1[[i]]))
{
print(i)
break
}
}
vecP1 <- list(a,b,u,v)
for(i in seq_along(vecP1))
{
if(is.ort(x,vecP1[[i]]))
{
print(i)
break
}
}
x%*%b
x*b
x = as.matrix(matrix(c(1:4), 2, 2, T))
det(x)
x <-  as.matrix(c(1:4))
x
##############
# Capítulo 3 #
##############
y <- as.matrix(c(11:14))
y
inv(x)
solve(t(x)%*%x)%*%t(x)%*%y
solve(x)
t(x)%*%x
##############
# Capítulo 3 #
##############
y <- as.matrix(c(11:13))
x <-  as.matrix(matrix(c(1:4), 2, 2, T))
x
y
##############
# Capítulo 3 #
##############
y <- as.matrix(c(11:12))
y
det(x)
solve(t(x)%*%x)%*%t(x)%*%y
