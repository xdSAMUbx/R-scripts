library(sp)
library(sf)
library(dplyr)
library(Rfast)
setwd("D:/Universidad/8 Semestre/Econometria/scripts/Pruebas") # PC
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 30000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
# Matriz de distancias sin considerar vecinos
phiIJ <- as.matrix(Dist(as.matrix(dfData[, c("x", "y")]), method = "euclidean"))
phiI0 <- as.matrix(dista(as.matrix(dfData[, c("x", "y")]), coordinates(as(ptsSample, "SpatialPoints"))))
eta <- 0.2
# Calula la multicuadrática
MQ <- sqrt(phiIJ^2 + eta^2)
# Calculando rho
rho <- 0.5
MQ <- MQ + diag(rep(rho, nrow(MQ)))
# Realizando el calculo vectorial
f <- matrix(rep(1, nrow(MQ)))
A <- cbind(rbind(MQ, t(f)), rbind(f, 0))
z <- as.matrix(dfData[, c("z")])
QA <- qr(A, LAPACK = TRUE)
if (nrow(phiI0) != nrow(dfData)) phiI0 <- t(phiI0)
nData <- nrow(dfData)
B <- rbind(phiI0, rep(1, ncol(phiI0)))   # (nData+1) x nPhi
# Resolver todos los sistemas de una vez usando la factorización QR ya hecha
coef_mat <- qr.coef(QA, B)               # (nData+1) x nPhi
# Calcular pred con un solo producto matricial
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
ptsSample$pred <- pred
plot(ptsSample)
ptsSample <- spsample(ariari, 30000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
# Matriz de distancias sin considerar vecinos
phiIJ <- as.matrix(Dist(as.matrix(dfData[, c("x", "y")]), method = "euclidean"))
phiI0 <- as.matrix(dista(as.matrix(dfData[, c("x", "y")]), coordinates(as(ptsSample, "SpatialPoints"))))
eta <- 0.2
# Calula la multicuadrática
MQ <- sqrt(phiIJ^2 + eta^2)
# Calculando rho
rho <- 0.5
MQ <- MQ + diag(rep(rho, nrow(MQ)))
# Realizando el calculo vectorial
f <- matrix(rep(1, nrow(MQ)))
A <- cbind(rbind(MQ, t(f)), rbind(f, 0))
z <- as.matrix(dfData[, c("z")])
QA <- qr(A, LAPACK = TRUE)
if (nrow(phiI0) != nrow(dfData)) phiI0 <- t(phiI0)
nData <- nrow(dfData)
B <- rbind(phiI0, rep(1, ncol(phiI0)))   # (nData+1) x nPhi
time <- system.time({
# Resolver todos los sistemas de una vez usando la factorización QR ya hecha
coef_mat <- qr.coef(QA, B)               # (nData+1) x nPhi
# Calcular pred con un solo producto matricial
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
})
ptsSample$pred <- pred
plot(ptsSample)
print(time)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
# Matriz de distancias sin considerar vecinos
phiIJ <- as.matrix(Dist(as.matrix(dfData[, c("x", "y")]), method = "euclidean"))
phiI0 <- as.matrix(dista(as.matrix(dfData[, c("x", "y")]), coordinates(as(ptsSample, "SpatialPoints"))))
eta <- 0.2
# Calula la multicuadrática
MQ <- sqrt(phiIJ^2 + eta^2)
# Calculando rho
rho <- 0.5
MQ <- MQ + diag(rep(rho, nrow(MQ)))
# Realizando el calculo vectorial
f <- matrix(rep(1, nrow(MQ)))
A <- cbind(rbind(MQ, t(f)), rbind(f, 0))
z <- as.matrix(dfData[, c("z")])
QA <- qr(A, LAPACK = TRUE)
if (nrow(phiI0) != nrow(dfData)) phiI0 <- t(phiI0)
nData <- nrow(dfData)
B <- rbind(phiI0, rep(1, ncol(phiI0)))   # (nData+1) x nPhi
time <- system.time({
# Resolver todos los sistemas de una vez usando la factorización QR ya hecha
coef_mat <- qr.coef(QA, B)               # (nData+1) x nPhi
# Calcular pred con un solo producto matricial
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
})
ptsSample$pred <- pred
plot(ptsSample)
print(time)
library(sf)
library(sp)
library(Rfast)
setwd("D:/programacion/R-scripts/Pruebas") # Portatil
library(sf)
library(sp)
library(Rfast)
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
f <- as.formula("z~x+y")
f
f[[1]]
f[[0]]
f[[2]]
f[[3]]
str(f)
dfData
s <- coordinates(dfData[,c("x","y")])
s
class(s)
f <- as.formula("z~x+y")
f
str(f)
f[[2]]
f[[3]]
f[[3]]$1
f <- as.formula("z~x+y")
terms(f)
attr(,"factors")
attr(f,"factors")
attr(f,"term.labels")
attr(,"term.labels")
f <- as.formula("z~x+y")
f.attr(,"term.labels")
terms(f)
attr(terms(f),"term.labels")
f <- as.formula("z~x+y+x*y")
attr(terms(f),"term.labels")
f <- as.formula("z~x+y")
attr(terms(f),"term.labels")
as.character(attr(trms, "variables")[[2]])
trms <- terms(f)
attr(trms,"term.labels")
as.character(attr(trms, "variables")[[2]])
dfData$x
attr(trms,"variables")
attr(trms,"variables")[[1]]
attr(trms,"variables")[[2]]
attr(trms,"variables")[[3]]
as.character(attr(trms, "variables")[[2]]) # z
as.character(attr(trms, "variables")[[3]]) # x
as.character(attr(trms, "variables")[[4]]) # y
dfData$as.character(attr(trms, "variables")[[4]]) # y
dfData$(as.character(attr(trms, "variables")[[4]])) # y
class(dfData)
class(ptsSample)
class(ptsSample) == "SpatialPixels"
# Matriz de distancias sin considerar vecinos
phiIJ <- as.matrix(Dist(as.matrix(dfData[, c("x", "y")]), method = "euclidean"))
phiI0 <- as.matrix(dista(as.matrix(dfData[, c("x", "y")]), coordinates(as(ptsSample, "SpatialPoints"))))
eta <- 0.2
# Calula la multicuadrática
MQ <- sqrt(phiIJ^2 + eta^2)
# Calculando rho
rho <- 0.5
diag(MQ) <- diag(MQ) + rho
MQ
rbfpred(dfData, ptsSample, 0.2, 0.5, 'MQ')
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) {
stop("El valor de eta no es un valor numérico")
}
if (!is.numeric(rho)) {
stop("El valor de rho no es un valor numérico")
}
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) {
stop("La función no esta definida dentro de los parametros")
}
stopifnot(class(newdata) == "SpatialPixels")
coords <- as.matrix(data[, c("x", "y")])
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
func <-  switch(rbf,
M = sqrt(phiIJ * phiIJ + eta * eta),
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
rbfpred(dfData, ptsSample, 0.2, 0.5, 'MQ')
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) {
stop("El valor de eta no es un valor numérico")
}
if (!is.numeric(rho)) {
stop("El valor de rho no es un valor numérico")
}
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) {
stop("La función no esta definida dentro de los parametros")
}
stopifnot(class(newdata) == "SpatialPixels")
coords <- as.matrix(data[, c("x", "y")])
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
func <-  switch(rbf,
M = sqrt(phiIJ * phiIJ + eta * eta),
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
rbfpred(dfData, ptsSample, 0.2, 0.5, "MQ")
rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
x11()
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
# Matriz de distancias sin considerar vecinos
phiIJ <- as.matrix(Dist(as.matrix(dfData[, c("x", "y")]), method = "euclidean"))
phiI0 <- as.matrix(dista(as.matrix(dfData[, c("x", "y")]), coordinates(as(ptsSample, "SpatialPoints"))))
eta <- 0.2
# Calula la multicuadrática
MQ <- sqrt(phiIJ^2 + eta^2)
# Calculando rho
rho <- 0.5
diag(MQ) <- diag(MQ) + rho
# Realizando el calculo vectorial
f <- matrix(rep(1, nrow(MQ)))
A <- cbind(rbind(MQ, t(f)), rbind(f, 0))
z <- as.matrix(dfData[, c("z")])
QA <- qr(A, LAPACK = TRUE)
if (nrow(phiI0) != nrow(dfData)) phiI0 <- t(phiI0)
nData <- nrow(dfData)
B <- rbind(phiI0, rep(1, ncol(phiI0)))   # (nData+1) x nPhi
time <- system.time({
# Resolver todos los sistemas de una vez usando la factorización QR ya hecha
coef_mat <- qr.coef(QA, B)               # (nData+1) x nPhi
# Calcular pred con un solo producto matricial
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
})
ptsSample$pred <- pred
plot(ptsSample)
print(time)
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) {
stop("El valor de eta no es un valor numérico")
}
if (!is.numeric(rho)) {
stop("El valor de rho no es un valor numérico")
}
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) {
stop("La función no esta definida dentro de los parametros")
}
stopifnot(class(newdata) == "SpatialPixels")
coords <- as.matrix(data[, c("x", "y")])
# Dependencia libreria Rfast
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
func <-  switch(rbf,
M = sqrt(phiIJ * phiIJ + eta * eta),
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
debugger(rbfPred)
rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
class(ptsSample)
class(ptsSample)[1]
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) {
stop("El valor de eta no es un valor numérico")
}
if (!is.numeric(rho)) {
stop("El valor de rho no es un valor numérico")
}
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) {
stop("La función no esta definida dentro de los parametros")
}
stopifnot(class(newdata)[1] == "SpatialPixels")
coords <- as.matrix(data[, c("x", "y")])
# Dependencia libreria Rfast
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
func <-  switch(rbf,
M = sqrt(phiIJ * phiIJ + eta * eta),
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
debugger(rbfPred)
rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) {
stop("El valor de eta no es un valor numérico")
}
if (!is.numeric(rho)) {
stop("El valor de rho no es un valor numérico")
}
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) {
stop("La función no esta definida dentro de los parametros")
}
stopifnot(class(newdata)[1] == "SpatialPixels")
coords <- as.matrix(data[, c("x", "y")])
# Dependencia libreria Rfast
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
func <-  switch(rbf,
MQ = sqrt(phiIJ * phiIJ + eta * eta),
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
pred
install.packages("expint")
library(expint)
library(sf)
library(sp)
library(Rfast)
library(expint)
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
rbfPred <- function(data, newdata, eta, rho, rbf) {
if (!is.numeric(eta)) stop("El valor de eta no es un valor numérico")
if (!is.numeric(rho)) stop("El valor de rho no es un valor numérico")
if (!(rbf %in% c("MQ", "IM", "ST", "TPS", "CRS", "GAU", "EXP"))) stop("La función no esta definida dentro de los parametros")
stopifnot(inherits(newdata, "SpatialPixels"))
stopifnot(is.numeric(eta), eta > 0)
# Cambio a futuro
coords <- as.matrix(data[, c("x", "y")])
# Dependencia libreria Rfast
phiIJ <- as.matrix(Dist(coords, method = "euclidean"))
phiI0 <- as.matrix(dista(coords, coordinates(as(newdata, "SpatialPoints"))))
n <- nrow(phiIJ)
nData <- nrow(data)
# Calculo funciones de base radial
etafi <- eta * phiIJ
EULER  <- 0.5772156649015329  # Constante de Euler
func <-  switch(rbf,
MQ = sqrt(phiIJ * phiIJ + eta * eta), # Multicuadrática
IM = 1 / sqrt(phiIJ * phiIJ + eta * eta), # Inversa Multicuadrática
TPS = ifelse(phiIJ == 0, 0, (etafi) * (etafi) * log(etafi)), # Spline de Capa Delgada
ST = ifelse(phiIJ == 0, 0, log(etafi * 0.5) + besselK(etafi, 0) + EULER), # Spline con tensión
CRS = ifelse(phiIJ == 0, 0, ifelse(phiIJ > 0 & eta > 0,
log(etafi * 0.5) * log(etafi * 0.5) + expint_E1(etafi * 0.5) * expint_E1(etafi * 0.5) + EULER)), # Spline completamente Regularizado
GAU = exp(-etafi * phiIJ), # Gaussiana
EXP = exp(-etafi), # Exponencial
stop("RBF no implementado", rbf)
)
diag(func) <- diag(func) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- func
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(phiI0) != nData) phiI0 <- t(phiI0)
B <- rbind(phiI0, matrix(1.0, 1L, ncol(phiI0)))
QA <- qr(A, LAPACK = TRUE)
coef_mat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coef_mat[1:nData, , drop = FALSE]))
}
rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
pred
ptsSample$pred <- pred
x11()
plot(ptsSample)
pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "IM")
ptsSample$pred <- pred
pred1 <- rbfPred(dfData, ptsSample, 0.2, 0.5, "MQ")
ptsSample$pred <- pred1
plot(ptsSample)
X11()
pred2 <- rbfPred(dfData, ptsSample, 0.2, 0.5, "IM")
ptsSample$pred <- pred2
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "SP")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "ST")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "TPS")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "CRS")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "GAU")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "EXP")
plot(ptsSample)
ptsSample$pred <- rbfPred(dfData, ptsSample, 0.2, 0.5, "EXP")
plot(ptsSample)
