stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
tms <- terms(f)
if (attr(tms, "response") != 1) stop("Debe de haber una variable respuesta.")
res <- as.character(f[[2]])
vars <- attr(tms, "term.labels")
if (length(vars) < 2 || length(vars) > 2) stop("Unicamente se contempla el módelo con dos variables ")
list(z = data[[res]], x = data[[vars[1]]], y = data[[vars[2]]])
}
getFormula("z~x+k", data)
getFormula <- function(formula, data) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
tms <- terms(f)
if (attr(tms, "response") != 1) stop("Debe de haber una variable respuesta.")
res <- as.character(f[[2]])
vars <- attr(tms, "term.labels")
if (length(vars) < 2 || length(vars) > 2) stop("Unicamente se contempla el módelo con dos variables ")
if(!(vars %in% colnames(data))) stop("Una variable no corresponde.")
list(z = data[[res]], x = data[[vars[1]]], y = data[[vars[2]]])
}
getFormula("z~x+k", data)
getFormula <- function(formula, data) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if(ncol(mf) < 3L) stop("Se esperaban por lo menos 3 valores.")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+k", data)
getFormula <- function(formula, data) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3L) stop("Se esperaban por lo menos 3 valores.")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+y", data)
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+k", data)
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+y", data)
getFormula <- function(formula, data, na.action = na.fail) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+y", data)
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
list(z = mf[[1L]], x = mf[[2L]], y = mf[[3L]])
}
getFormula("z~x+y", data)
library(sf)
library(sp)
library(Rfast)
library(expint)
setwd("D:/programacion/R-scripts/Pruebas") # Portatil
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
library(sf)
library(sf)
library(sp)
library(Rfast)
library(expint)
library(dplyr)
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
coordinates(as(ptsSample, "SpatialPoints")
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
z <- mf[[1L]]
X <- as.matrix(mf[, -1, drop = FALSE])
if (!all(vapply(as.data.frame(X), is.numeric, logical(1L))))
stop("Los predictores deben ser numéricos.")
list(z = z, x = X)
}
getFormula("z~x+y", dfData)
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
m <- sqrt(dMat * dMat + eta * eta),
im <- 1 / sqrt(dMat * dMat + eta * eta),
exp <- exp(-etaDist),
gau <- exp(-etaDist * dMat),
tps <- ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
st <- ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
crs <- ifelse(dMat == 0, 0, (2 * log(etaDit * 0.5)) + expint_E1(etaDit * etaDit * 0.25) + EULER)
)
}
# Función para obtener los valores de la formula
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
z <- mf[[1L]]
X <- as.matrix(mf[, -1, drop = FALSE])
if (!all(vapply(as.data.frame(X), is.numeric, logical(1L))))
stop("Los predictores deben ser numéricos.")
list(z = z, x = X)
}
# Función para obtener el tipo de RBF
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
# Multicuadrática
m <- sqrt(dMat * dMat + eta * eta),
# Inversa multicuadrática
im <- 1 / sqrt(dMat * dMat + eta * eta),
# Exponencial
exp <- exp(-etaDist),
# Gaussiana
gau <- exp(-etaDist * dMat),
# Spline de capa delgada
tps <- ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
# Spline con tensión
st <- ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
# Spline completamente regularizado
crs <- ifelse(dMat == 0, 0, (2 * log(etaDist * 0.5)) + expint_E1(etaDist * etaDist * 0.25) + EULER)
)
}
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$X
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
phi <- pickRBF(func, dMat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
B <- rbind(d0Mat, matrix(1.0, 1L, ncol(d0Mat)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA,B)
pred <- as.numeric(crossprod(z, coefMat[1:nData, , drop = F]))
}
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
library(sf)
library(sp)
library(Rfast)
library(expint)
library(dplyr)
setwd("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas") # PC
data <- "data/ariari.rda"
data2 <- "data/ariprec.rda"
load(data)
load(data2)
ptsSample <- spsample(ariari, 50000, type = "regular")
gridded(ptsSample) <- TRUE
dfData <- ariprec %>% select("x", "y", "PRECI_TOT")
colnames(dfData)[3] <- "z"
# Función para obtener los valores de la formula
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
z <- mf[[1L]]
X <- as.matrix(mf[, -1, drop = FALSE])
if (!all(vapply(as.data.frame(X), is.numeric, logical(1L))))
stop("Los predictores deben ser numéricos.")
list(z = z, x = X)
}
# Función para obtener el tipo de RBF
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
# Multicuadrática
m = sqrt(dMat * dMat + eta * eta),
# Inversa multicuadrática
im = 1 / sqrt(dMat * dMat + eta * eta),
# Exponencial
exp = exp(-etaDist),
# Gaussiana
gau = exp(-etaDist * dMat),
# Spline de capa delgada
tps = ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
# Spline con tensión
st = ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
# Spline completamente regularizado
crs = ifelse(dMat == 0, 0, (2 * log(etaDist * 0.5)) + expint_E1(etaDist * etaDist * 0.25) + EULER)
)
}
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$X
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
phi <- pickRBF(func, dMat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
B <- rbind(d0Mat, matrix(1.0, 1L, ncol(d0Mat)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coefMat[1:nData, , drop = F]))
}
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
source("D:/Universidad/8 Semestre/Econometria/R-scripts/Pruebas/getFormula.R")
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$x
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
phi <- pickRBF(func, dMat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
B <- rbind(d0Mat, matrix(1.0, 1L, ncol(d0Mat)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coefMat[1:n, , drop = F]))
}
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
prueba1 <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
prueba1
prueba1 <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "CRS")
warnings()
prueba1 <- rbf("z~x+y", dfData, ptsSample, 0.5, 0.5, "CRS")
prueba1
prueba1 <- rbf("z~x+y", dfData, ptsSample, 0.5, 0.5, "IM")
prueba1
prueba1 <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "IM")
prueba1
x11()
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "IM")
plot(ptsSample)
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
# Multicuadrática
m = sqrt(dMat * dMat + eta * eta),
# Inversa multicuadrática
im = (sqrt(dMat * dMat + eta * eta))^(-1),
# Exponencial
exp = exp(-etaDist),
# Gaussiana
gau = exp(-etaDist * dMat),
# Spline de capa delgada
tps = ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
# Spline con tensión
st = ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
# Spline completamente regularizado
crs = ifelse(dMat == 0, 0, (2 * log(etaDist * 0.5)) + expint_E1(etaDist * etaDist * 0.25) + EULER)
)
}
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$x
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
phi <- pickRBF(func, dMat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
B <- rbind(d0Mat, matrix(1.0, 1L, ncol(d0Mat)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coefMat[1:n, , drop = F]))
}
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "IM")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "ST")
plot(ptsSample)
# Función para obtener los valores de la formula
getFormula <- function(formula, data, na.action = na.action) {
stopifnot(inherits(formula, "character") || inherits(formula, "formula"))
stopifnot(inherits(data, "data.frame"))
f <- as.formula(formula)
mf <- model.frame(f, data = data, na.action = na.action)
if (ncol(mf) < 3) stop("Se esperaban por lo menos 3 valores")
z <- mf[[1L]]
X <- as.matrix(mf[, -1, drop = FALSE])
if (!all(vapply(as.data.frame(X), is.numeric, logical(1L))))
stop("Los predictores deben ser numéricos.")
list(z = z, x = X)
}
# Función para obtener el tipo de RBF
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
# Multicuadrática
m = sqrt(dMat * dMat + eta * eta),
# Inversa multicuadrática
im = (sqrt(dMat * dMat + eta * eta))^(-1),
# Exponencial
exp = exp(-etaDist),
# Gaussiana
gau = exp(-etaDist * dMat),
# Spline de capa delgada
tps = ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
# Spline con tensión
st = ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
# Spline completamente regularizado
crs = ifelse(dMat == 0, 0, (2 * log(etaDist * 0.5)) + expint_E1(etaDist * etaDist * 0.25) + EULER)
)
}
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$x
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
phi <- pickRBF(func, dMat, eta)
phi0 <- pickRBF(func, d0Mat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
B <- rbind(phi0, matrix(1.0, 1L, ncol(phi0)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coefMat[1:n, , drop = F]))
}
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "ST")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "M")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "IM")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "ST")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "TPS")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "CRS")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "CRS")
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.1, 0.1, "exp")
plot(ptsSample)
ptsSample$pred
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.5, 0.5, "exp")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "exp")
plot(ptsSample)
ot(is.numeric(eta))
# Función para obtener el tipo de RBF
pickRBF <- function(func, dMat, eta) {
stopifnot(is.character(func))
stopifnot(is.numeric(eta))
stopifnot(inherits(dMat, "matrix"))
if (eta <= 0) stop("Eta tiene que ser mayor a 0")
etaDist <- dMat * eta
EULER <- 0.5772156649015329
switch(tolower(func),
# Multicuadrática
m = sqrt(dMat * dMat + eta * eta),
# Inversa multicuadrática
im = (sqrt(dMat * dMat + eta * eta))^(-1),
# Exponencial
exp = exp(-(etaDist)),
# Gaussiana
gau = exp(-etaDist * dMat),
# Spline de capa delgada
tps = ifelse(dMat == 0, 0, etaDist * etaDist * log(etaDist)),
# Spline con tensión
st = ifelse(dMat == 0, 0, log(etaDist * 0.5) + besselK(etaDist, 0) + EULER),
# Spline completamente regularizado
crs = ifelse(dMat == 0, 0, (2 * log(etaDist * 0.5)) + expint_E1(etaDist * etaDist * 0.25) + EULER)
)
}
rbf <- function(formula, data, newData, eta, rho, func) {
stopifnot(is.numeric(rho), is.data.frame(data), inherits(newData, "SpatialPixels"))
formula <- getFormula(formula, data)
z <- formula$z
coords <- formula$x
dMat <- as.matrix(Dist(coords, method = "euclidean"))
d0Mat <- as.matrix(dista(coords, coordinates(as(newData, "SpatialPoints"))))
n <- nrow(dMat)
nData <- nrow(data)
if (nrow(d0Mat) != nData) d0Mat <- t(d0Mat)
phi <- pickRBF(func, dMat, eta)
phi0 <- pickRBF(func, d0Mat, eta)
diag(phi) <- diag(phi) + rho
A <- matrix(0.0, n + 1L, n + 1L)
A[1:n, 1:n] <- phi
A[1:n, n + 1L] <- 1.0
A[n + 1L, 1:n] <- 1.0
B <- rbind(phi0, matrix(1.0, 1L, ncol(phi0)))
QA <- qr(A, LAPACK = T)
coefMat <- qr.coef(QA, B)
pred <- as.numeric(crossprod(z, coefMat[1:n, , drop = F]))
}
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "exp")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "m")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "im")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "gau")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "tps")
plot(ptsSample)
ptsSample$pred <- rbf("z~x+y", dfData, ptsSample, 0.2, 0.2, "st")
plot(ptsSample)
